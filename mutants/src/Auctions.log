*** UNIVERSALMUTATOR ***
MUTATING WITH RULES: universal.rules, solidity.rules, c_like.rules
SKIPPED 182 MUTANTS ONLY CHANGING STRING LITERALS
15110 MUTANTS GENERATED BY RULES
PROCESSING MUTANT: 66:         address borrower;        // borrower address to take from  ==>          address borrower;        //  address to take from...VALID [written to mutants/Auctions/Auctions.mutant.0.sol] 
PROCESSING MUTANT: 67:         bool    depositTake;     // deposit or arb take, used by bucket take  ==>          bool    depositTake;     //  or arb take, used by bucket take...VALID [written to mutants/Auctions/Auctions.mutant.1.sol] 
PROCESSING MUTANT: 68:         uint256 index;           // bucket index, used by bucket take  ==>          uint256 index;           //  index, used by bucket take...VALID [written to mutants/Auctions/Auctions.mutant.2.sol] 
PROCESSING MUTANT: 69:         uint256 inflator;        // [WAD] current pool inflator  ==>          uint256 inflator;        //  current pool inflator...VALID [written to mutants/Auctions/Auctions.mutant.3.sol] 
PROCESSING MUTANT: 70:         uint256 collateralScale; // precision of collateral token based on decimals  ==>          uint256 collateralScale; //  of collateral token based on decimals...VALID [written to mutants/Auctions/Auctions.mutant.4.sol] 
PROCESSING MUTANT: 73:         address borrower;        // borrower address to take from  ==>          address borrower;        //  address to take from...VALID [written to mutants/Auctions/Auctions.mutant.5.sol] 
PROCESSING MUTANT: 74:         uint256 takeCollateral;  // [WAD] desired amount to take  ==>          uint256 takeCollateral;  //  desired amount to take...VALID [written to mutants/Auctions/Auctions.mutant.6.sol] 
PROCESSING MUTANT: 75:         uint256 inflator;        // [WAD] current pool inflator  ==>          uint256 inflator;        //  current pool inflator...VALID [written to mutants/Auctions/Auctions.mutant.7.sol] 
PROCESSING MUTANT: 76:         uint256 poolType;        // pool type (ERC20 or NFT)  ==>          uint256 poolType;        // pool type (ERC0 or NFT)...VALID [written to mutants/Auctions/Auctions.mutant.8.sol] 
PROCESSING MUTANT: 76:         uint256 poolType;        // pool type (ERC20 or NFT)  ==>          uint256 poolType;        // pool type (ERC1 or NFT)...VALID [written to mutants/Auctions/Auctions.mutant.9.sol] 
PROCESSING MUTANT: 76:         uint256 poolType;        // pool type (ERC20 or NFT)  ==>          uint256 poolType;        // pool type (ERC-1 or NFT)...VALID [written to mutants/Auctions/Auctions.mutant.10.sol] 
PROCESSING MUTANT: 76:         uint256 poolType;        // pool type (ERC20 or NFT)  ==>          uint256 poolType;        // pool type (ERC(20+1) or NFT)...VALID [written to mutants/Auctions/Auctions.mutant.11.sol] 
PROCESSING MUTANT: 76:         uint256 poolType;        // pool type (ERC20 or NFT)  ==>          uint256 poolType;        // pool type (ERC(20-1) or NFT)...VALID [written to mutants/Auctions/Auctions.mutant.12.sol] 
PROCESSING MUTANT: 76:         uint256 poolType;        // pool type (ERC20 or NFT)  ==>          uint256 poolType;        //  type (ERC20 or NFT)...VALID [written to mutants/Auctions/Auctions.mutant.13.sol] 
PROCESSING MUTANT: 77:         uint256 collateralScale; // precision of collateral token based on decimals  ==>          uint256 collateralScale; //  of collateral token based on decimals...VALID [written to mutants/Auctions/Auctions.mutant.14.sol] 
PROCESSING MUTANT: 85:         uint256 borrowerDebt;       // [WAD] the accrued debt of kicked borrower  ==>          uint256 borrowerDebt;       //  the accrued debt of kicked borrower...VALID [written to mutants/Auctions/Auctions.mutant.15.sol] 
PROCESSING MUTANT: 86:         uint256 borrowerCollateral; // [WAD] amount of kicked borrower collateral  ==>          uint256 borrowerCollateral; //  amount of kicked borrower collateral...VALID [written to mutants/Auctions/Auctions.mutant.16.sol] 
PROCESSING MUTANT: 87:         uint256 neutralPrice;       // [WAD] neutral price recorded in kick action  ==>          uint256 neutralPrice;       //  neutral price recorded in kick action...VALID [written to mutants/Auctions/Auctions.mutant.17.sol] 
PROCESSING MUTANT: 88:         uint256 noOfLoans;          // number of loans and auctions in pool (used to calculate MOMP)  ==>          uint256 noOfLoans;          //  of loans and auctions in pool (used to calculate MOMP)...VALID [written to mutants/Auctions/Auctions.mutant.18.sol] 
PROCESSING MUTANT: 89:         uint256 momp;               // [WAD] MOMP of kicked auction  ==>          uint256 momp;               //  MOMP of kicked auction...VALID [written to mutants/Auctions/Auctions.mutant.19.sol] 
PROCESSING MUTANT: 90:         uint256 bondFactor;         // [WAD] bond factor of kicked auction  ==>          uint256 bondFactor;         //  bond factor of kicked auction...VALID [written to mutants/Auctions/Auctions.mutant.20.sol] 
PROCESSING MUTANT: 91:         uint256 bondSize;           // [WAD] bond size of kicked auction  ==>          uint256 bondSize;           //  bond size of kicked auction...VALID [written to mutants/Auctions/Auctions.mutant.21.sol] 
PROCESSING MUTANT: 92:         uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty  ==>          uint256 t0KickPenalty;      // [WAD] t1 debt added as kick penalty...VALID [written to mutants/Auctions/Auctions.mutant.22.sol] 
PROCESSING MUTANT: 92:         uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty  ==>          uint256 t0KickPenalty;      // [WAD] t-1 debt added as kick penalty...VALID [written to mutants/Auctions/Auctions.mutant.23.sol] 
PROCESSING MUTANT: 92:         uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty  ==>          uint256 t0KickPenalty;      // [WAD] t(0+1) debt added as kick penalty...VALID [written to mutants/Auctions/Auctions.mutant.24.sol] 
PROCESSING MUTANT: 92:         uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty  ==>          uint256 t0KickPenalty;      // [WAD] t(0-1) debt added as kick penalty...VALID [written to mutants/Auctions/Auctions.mutant.25.sol] 
PROCESSING MUTANT: 92:         uint256 t0KickPenalty;      // [WAD] t0 debt added as kick penalty  ==>          uint256 t0KickPenalty;      //  t0 debt added as kick penalty...VALID [written to mutants/Auctions/Auctions.mutant.26.sol] 
PROCESSING MUTANT: 93:         uint256 kickPenalty;        // [WAD] current debt added as kick penalty  ==>          uint256 kickPenalty;        //  current debt added as kick penalty...VALID [written to mutants/Auctions/Auctions.mutant.27.sol] 
PROCESSING MUTANT: 96:         uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit  ==>          uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lbeginer deposit...VALID [written to mutants/Auctions/Auctions.mutant.28.sol] 
PROCESSING MUTANT: 96:         uint256 amountToDebitFromDeposit; // [WAD] the amount of quote tokens used to kick and debited from lender deposit  ==>          uint256 amountToDebitFromDeposit; //  the amount of quote tokens used to kick and debited from lender deposit...VALID [written to mutants/Auctions/Auctions.mutant.29.sol] 
PROCESSING MUTANT: 97:         uint256 bucketCollateral;         // [WAD] amount of collateral in bucket  ==>          uint256 bucketCollateral;         //  amount of collateral in bucket...VALID [written to mutants/Auctions/Auctions.mutant.30.sol] 
PROCESSING MUTANT: 98:         uint256 bucketDeposit;            // [WAD] amount of quote tokens in bucket  ==>          uint256 bucketDeposit;            //  amount of quote tokens in bucket...VALID [written to mutants/Auctions/Auctions.mutant.31.sol] 
PROCESSING MUTANT: 99:         uint256 bucketLPs;                // [WAD] LPs of the bucket  ==>          uint256 bucketLPs;                //  LPs of the bucket...VALID [written to mutants/Auctions/Auctions.mutant.32.sol] 
PROCESSING MUTANT: 100:         uint256 bucketPrice;              // [WAD] bucket price  ==>          uint256 bucketPrice;              //  bucket price...VALID [written to mutants/Auctions/Auctions.mutant.33.sol] 
PROCESSING MUTANT: 101:         uint256 bucketRate;               // [WAD] bucket exchange rate  ==>          uint256 bucketRate;               //  bucket exchange rate...VALID [written to mutants/Auctions/Auctions.mutant.34.sol] 
PROCESSING MUTANT: 102:         uint256 bucketScale;              // [WAD] bucket scales  ==>          uint256 bucketScale;              //  bucket scales...VALID [written to mutants/Auctions/Auctions.mutant.35.sol] 
PROCESSING MUTANT: 103:         uint256 bucketUnscaledDeposit;    // [WAD] unscaled amount of quote tokens in bucket  ==>          uint256 bucketUnscaledDeposit;    //  unscaled amount of quote tokens in bucket...VALID [written to mutants/Auctions/Auctions.mutant.36.sol] 
PROCESSING MUTANT: 104:         uint256 lenderLPs;                // [WAD] LPs of lender in bucket  ==>          uint256 lenderLPs;                // [WAD] LPs of lbeginer in bucket...VALID [written to mutants/Auctions/Auctions.mutant.37.sol] 
PROCESSING MUTANT: 104:         uint256 lenderLPs;                // [WAD] LPs of lender in bucket  ==>          uint256 lenderLPs;                //  LPs of lender in bucket...VALID [written to mutants/Auctions/Auctions.mutant.38.sol] 
PROCESSING MUTANT: 105:         uint256 redeemedLPs;              // [WAD] LPs used by kick action  ==>          uint256 redeemedLPs;              //  LPs used by kick action...VALID [written to mutants/Auctions/Auctions.mutant.39.sol] 
PROCESSING MUTANT: 108:         uint256 collateralUsed;    // [WAD] collateral used to settle debt  ==>          uint256 collateralUsed;    //  collateral used to settle debt...VALID [written to mutants/Auctions/Auctions.mutant.40.sol] 
PROCESSING MUTANT: 109:         uint256 debt;              // [WAD] debt to settle  ==>          uint256 debt;              //  debt to settle...VALID [written to mutants/Auctions/Auctions.mutant.41.sol] 
PROCESSING MUTANT: 110:         uint256 depositToRemove;   // [WAD] deposit used by settle auction  ==>          uint256 depositToRemove;   //  deposit used by settle auction...VALID [written to mutants/Auctions/Auctions.mutant.42.sol] 
PROCESSING MUTANT: 111:         uint256 index;             // index of settling bucket  ==>          uint256 index;             //  of settling bucket...VALID [written to mutants/Auctions/Auctions.mutant.43.sol] 
PROCESSING MUTANT: 112:         uint256 maxSettleableDebt; // [WAD] max amount that can be settled with existing collateral  ==>          uint256 maxSettleableDebt; // [WAD] min amount that can be settled with existing collateral...VALID [written to mutants/Auctions/Auctions.mutant.44.sol] 
PROCESSING MUTANT: 112:         uint256 maxSettleableDebt; // [WAD] max amount that can be settled with existing collateral  ==>          uint256 maxSettleableDebt; //  max amount that can be settled with existing collateral...VALID [written to mutants/Auctions/Auctions.mutant.45.sol] 
PROCESSING MUTANT: 113:         uint256 price;             // [WAD] price of settling bucket  ==>          uint256 price;             //  price of settling bucket...VALID [written to mutants/Auctions/Auctions.mutant.46.sol] 
PROCESSING MUTANT: 114:         uint256 scaledDeposit;     // [WAD] scaled amount of quote tokens in bucket  ==>          uint256 scaledDeposit;     //  scaled amount of quote tokens in bucket...VALID [written to mutants/Auctions/Auctions.mutant.47.sol] 
PROCESSING MUTANT: 115:         uint256 scale;             // [WAD] scale of settling bucket  ==>          uint256 scale;             //  scale of settling bucket...VALID [written to mutants/Auctions/Auctions.mutant.48.sol] 
PROCESSING MUTANT: 116:         uint256 unscaledDeposit;   // [WAD] unscaled amount of quote tokens in bucket  ==>          uint256 unscaledDeposit;   //  unscaled amount of quote tokens in bucket...VALID [written to mutants/Auctions/Auctions.mutant.49.sol] 
PROCESSING MUTANT: 119:         uint256 auctionPrice;             // [WAD] The price of auction.  ==>          uint256 auctionPrice;             //  The price of auction....VALID [written to mutants/Auctions/Auctions.mutant.50.sol] 
PROCESSING MUTANT: 120:         uint256 bondChange;               // [WAD] The change made on the bond size (beeing reward or penalty).  ==>          uint256 bondChange;               //  The change made on the bond size (beeing reward or penalty)....VALID [written to mutants/Auctions/Auctions.mutant.51.sol] 
PROCESSING MUTANT: 121:         uint256 borrowerDebt;             // [WAD] The accrued debt of auctioned borrower.  ==>          uint256 borrowerDebt;             //  The accrued debt of auctioned borrower....VALID [written to mutants/Auctions/Auctions.mutant.52.sol] 
PROCESSING MUTANT: 122:         int256  bpf;                      // The bond penalty factor.  ==>          int256  bpf;                      //  bond penalty factor....VALID [written to mutants/Auctions/Auctions.mutant.53.sol] 
PROCESSING MUTANT: 123:         uint256 bucketPrice;              // [WAD] The bucket price.  ==>          uint256 bucketPrice;              //  The bucket price....VALID [written to mutants/Auctions/Auctions.mutant.54.sol] 
PROCESSING MUTANT: 124:         uint256 bucketScale;              // [WAD] The bucket scale.  ==>          uint256 bucketScale;              //  The bucket scale....VALID [written to mutants/Auctions/Auctions.mutant.55.sol] 
PROCESSING MUTANT: 125:         uint256 collateralAmount;         // [WAD] The amount of collateral taken.  ==>          uint256 collateralAmount;         //  The amount of collateral taken....VALID [written to mutants/Auctions/Auctions.mutant.56.sol] 
PROCESSING MUTANT: 126:         uint256 excessQuoteToken;         // [WAD] Difference of quote token that borrower receives after take (for fractional NFT only)  ==>          uint256 excessQuoteToken;         //  Difference of quote token that borrower receives after take (for fractional NFT only)...VALID [written to mutants/Auctions/Auctions.mutant.57.sol] 
PROCESSING MUTANT: 127:         uint256 factor;                   // The take factor, calculated based on bond penalty factor.  ==>          uint256 factor;                   //  take factor, calculated based on bond penalty factor....VALID [written to mutants/Auctions/Auctions.mutant.58.sol] 
PROCESSING MUTANT: 128:         bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).  ==>          bool    isRewarded;               // True if kicker is rewarded ( false if penalized (auction price greater than neutral price,auction price lower than neutral price))....VALID [written to mutants/Auctions/Auctions.mutant.59.sol] 
PROCESSING MUTANT: 128:         bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).  ==>          bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), true if penalized (auction price greater than neutral price)....VALID [written to mutants/Auctions/Auctions.mutant.60.sol] 
PROCESSING MUTANT: 128:         bool    isRewarded;               // True if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price).  ==>          bool    isRewarded;               //  if kicker is rewarded (auction price lower than neutral price), false if penalized (auction price greater than neutral price)....VALID [written to mutants/Auctions/Auctions.mutant.61.sol] 
PROCESSING MUTANT: 129:         address kicker;                   // Address of auction kicker.  ==>          address kicker;                   //  of auction kicker....VALID [written to mutants/Auctions/Auctions.mutant.62.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1+bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.63.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1*bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.64.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1/bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.65.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1%bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.66.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.67.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 0-bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.68.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before -1-bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.69.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before (1+1)-bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.70.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before (1-1)-bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.71.sol] 
PROCESSING MUTANT: 130:         uint256 quoteTokenAmount;         // [WAD] Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral  ==>          uint256 quoteTokenAmount;         //  Scaled quantity in Fenwick tree and before 1-bpf factor, paid for collateral...VALID [written to mutants/Auctions/Auctions.mutant.72.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered + repayed by take t0 terms....VALID [written to mutants/Auctions/Auctions.mutant.73.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered - repayed by take t0 terms....VALID [written to mutants/Auctions/Auctions.mutant.74.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered * repayed by take t0 terms....VALID [written to mutants/Auctions/Auctions.mutant.75.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered % repayed by take t0 terms....VALID [written to mutants/Auctions/Auctions.mutant.76.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t1 terms....VALID [written to mutants/Auctions/Auctions.mutant.77.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t-1 terms....VALID [written to mutants/Auctions/Auctions.mutant.78.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t(0+1) terms....VALID [written to mutants/Auctions/Auctions.mutant.79.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t(0-1) terms....VALID [written to mutants/Auctions/Auctions.mutant.80.sol] 
PROCESSING MUTANT: 131:         uint256 t0RepayAmount;            // [WAD] The amount of debt (quote tokens) that is recovered / repayed by take t0 terms.  ==>          uint256 t0RepayAmount;            //  The amount of debt (quote tokens) that is recovered / repayed by take t0 terms....VALID [written to mutants/Auctions/Auctions.mutant.81.sol] 
PROCESSING MUTANT: 132:         uint256 t0BorrowerDebt;           // [WAD] Borrower's t0 debt.  ==>          uint256 t0BorrowerDebt;           // [WAD] Borrower's t1 debt....VALID [written to mutants/Auctions/Auctions.mutant.82.sol] 
PROCESSING MUTANT: 132:         uint256 t0BorrowerDebt;           // [WAD] Borrower's t0 debt.  ==>          uint256 t0BorrowerDebt;           // [WAD] Borrower's t-1 debt....VALID [written to mutants/Auctions/Auctions.mutant.83.sol] 
PROCESSING MUTANT: 132:         uint256 t0BorrowerDebt;           // [WAD] Borrower's t0 debt.  ==>          uint256 t0BorrowerDebt;           // [WAD] Borrower's t(0+1) debt....VALID [written to mutants/Auctions/Auctions.mutant.84.sol] 
PROCESSING MUTANT: 132:         uint256 t0BorrowerDebt;           // [WAD] Borrower's t0 debt.  ==>          uint256 t0BorrowerDebt;           // [WAD] Borrower's t(0-1) debt....VALID [written to mutants/Auctions/Auctions.mutant.85.sol] 
PROCESSING MUTANT: 132:         uint256 t0BorrowerDebt;           // [WAD] Borrower's t0 debt.  ==>          uint256 t0BorrowerDebt;           //  Borrower's t0 debt....VALID [written to mutants/Auctions/Auctions.mutant.86.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty + 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.87.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty * 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.88.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty / 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.89.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty % 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.90.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7+ from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.91.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7- from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.92.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7* from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.93.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7/ from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.94.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty  7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.95.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t1 penalty - 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.96.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t-1 penalty - 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.97.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t(0+1) penalty - 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.98.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t(0-1) penalty - 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.99.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if uintial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.100.sol] 
PROCESSING MUTANT: 133:         uint256 t0DebtPenalty;            // [WAD] Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise.  ==>          uint256 t0DebtPenalty;            //  Borrower's t0 penalty - 7% from current debt if intial take, 0 otherwise....VALID [written to mutants/Auctions/Auctions.mutant.101.sol] 
PROCESSING MUTANT: 134:         uint256 unscaledDeposit;          // [WAD] Unscaled bucket quantity  ==>          uint256 unscaledDeposit;          //  Unscaled bucket quantity...VALID [written to mutants/Auctions/Auctions.mutant.102.sol] 
PROCESSING MUTANT: 135:         uint256 unscaledQuoteTokenAmount; // [WAD] The unscaled token amount that taker should pay for collateral taken.  ==>          uint256 unscaledQuoteTokenAmount; //  The unscaled token amount that taker should pay for collateral taken....VALID [written to mutants/Auctions/Auctions.mutant.103.sol] 
PROCESSING MUTANT: 144:     event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lps, uint256 index);  ==>      event AuctionNFTSettle(address indexed borrower, uint256 lps, uint256 collateral, uint256 index);...VALID [written to mutants/Auctions/Auctions.mutant.104.sol] 
PROCESSING MUTANT: 144:     event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lps, uint256 index);  ==>      event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 index, uint256 lps);...VALID [written to mutants/Auctions/Auctions.mutant.105.sol] 
PROCESSING MUTANT: 144:     event AuctionNFTSettle(address indexed borrower, uint256 collateral, uint256 lps, uint256 index);  ==>      event AuctionNFTSettle(address  borrower, uint256 collateral, uint256 lps, uint256 index);...VALID [written to mutants/Auctions/Auctions.mutant.106.sol] 
PROCESSING MUTANT: 145:     event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);  ==>      event BucketTake(address indexed borrower, uint256 amount, uint256 index, uint256 collateral, uint256 bondChange, bool isReward);...VALID [written to mutants/Auctions/Auctions.mutant.107.sol] 
PROCESSING MUTANT: 145:     event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);  ==>      event BucketTake(address indexed borrower, uint256 index, uint256 collateral, uint256 amount, uint256 bondChange, bool isReward);...VALID [written to mutants/Auctions/Auctions.mutant.108.sol] 
PROCESSING MUTANT: 145:     event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);  ==>      event BucketTake(address indexed borrower, uint256 index, uint256 amount, uint256 bondChange, uint256 collateral, bool isReward);...VALID [written to mutants/Auctions/Auctions.mutant.109.sol] 
PROCESSING MUTANT: 146:     event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);  ==>      event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedKicker, uint256 lpAwardedTaker);...VALID [written to mutants/Auctions/Auctions.mutant.110.sol] 
PROCESSING MUTANT: 146:     event BucketTakeLPAwarded(address indexed taker, address indexed kicker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);  ==>      event BucketTakeLPAwarded( address indexed kicker,address indexed taker, uint256 lpAwardedTaker, uint256 lpAwardedKicker);...VALID [written to mutants/Auctions/Auctions.mutant.111.sol] 
PROCESSING MUTANT: 147:     event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);  ==>      event Kick(address indexed borrower, uint256 collateral, uint256 debt, uint256 bond);...VALID [written to mutants/Auctions/Auctions.mutant.112.sol] 
PROCESSING MUTANT: 147:     event Kick(address indexed borrower, uint256 debt, uint256 collateral, uint256 bond);  ==>      event Kick(address indexed borrower, uint256 debt, uint256 bond, uint256 collateral);...VALID [written to mutants/Auctions/Auctions.mutant.113.sol] 
PROCESSING MUTANT: 148:     event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);  ==>      event Take(address indexed borrower, uint256 collateral, uint256 amount, uint256 bondChange, bool isReward);...VALID [written to mutants/Auctions/Auctions.mutant.114.sol] 
PROCESSING MUTANT: 148:     event Take(address indexed borrower, uint256 amount, uint256 collateral, uint256 bondChange, bool isReward);  ==>      event Take(address indexed borrower, uint256 amount, uint256 bondChange, uint256 collateral, bool isReward);...VALID [written to mutants/Auctions/Auctions.mutant.115.sol] 
PROCESSING MUTANT: 149:     event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);  ==>      event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 lpRedeemed, uint256 amount, uint256 lup);...VALID [written to mutants/Auctions/Auctions.mutant.116.sol] 
PROCESSING MUTANT: 149:     event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);  ==>      event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lup, uint256 lpRedeemed);...VALID [written to mutants/Auctions/Auctions.mutant.117.sol] 
PROCESSING MUTANT: 149:     event RemoveQuoteToken(address indexed lender, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);  ==>      event RemoveQuoteToken(address indexed lbeginer, uint256 indexed price, uint256 amount, uint256 lpRedeemed, uint256 lup);...VALID [written to mutants/Auctions/Auctions.mutant.118.sol] 
PROCESSING MUTANT: 150:     event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);  ==>      event ReserveAuction(uint256 claimableReservesRemaining, uint256 currentBurnEpoch, uint256 auctionPrice);...VALID [written to mutants/Auctions/Auctions.mutant.119.sol] 
PROCESSING MUTANT: 150:     event ReserveAuction(uint256 claimableReservesRemaining, uint256 auctionPrice, uint256 currentBurnEpoch);  ==>      event ReserveAuction( uint256 auctionPrice,uint256 claimableReservesRemaining, uint256 currentBurnEpoch);...VALID [written to mutants/Auctions/Auctions.mutant.120.sol] 
PROCESSING MUTANT: 158:     event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);  ==>      event BucketBankruptcy( uint256 lpForfeited,uint256 indexed index);...VALID [written to mutants/Auctions/Auctions.mutant.121.sol] 
PROCESSING MUTANT: 158:     event BucketBankruptcy(uint256 indexed index, uint256 lpForfeited);  ==>      event BucketBankruptcy(uint256  index, uint256 lpForfeited);...VALID [written to mutants/Auctions/Auctions.mutant.122.sol] 
PROCESSING MUTANT: 205:         if (kickTime == 0) revert NoAuction();  ==>          if (kickTime <= 0) revert NoAuction();...VALID [written to mutants/Auctions/Auctions.mutant.123.sol] 
PROCESSING MUTANT: 207:         Borrower memory borrower = loans_.borrowers[params_.borrower];  ==>          Borrower storage borrower = loans_.borrowers[params_.borrower];...VALID [written to mutants/Auctions/Auctions.mutant.124.sol] 
PROCESSING MUTANT: 208:         if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();  ==>          if ((block.timestamp % kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();...VALID [written to mutants/Auctions/Auctions.mutant.125.sol] 
PROCESSING MUTANT: 208:         if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();  ==>          if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral > 0)) revert AuctionNotClearable();...VALID [written to mutants/Auctions/Auctions.mutant.126.sol] 
PROCESSING MUTANT: 208:         if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();  ==>          if ((block.timestamp - kickTime <= 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();...VALID [written to mutants/Auctions/Auctions.mutant.127.sol] 
PROCESSING MUTANT: 208:         if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();  ==>          if ((block.timestamp - kickTime < 1 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();...VALID [written to mutants/Auctions/Auctions.mutant.128.sol] 
PROCESSING MUTANT: 208:         if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();  ==>          if ((block.timestamp - kickTime < 72 seconds) && (borrower.collateral != 0)) revert AuctionNotClearable();...VALID [written to mutants/Auctions/Auctions.mutant.129.sol] 
PROCESSING MUTANT: 208:         if ((block.timestamp - kickTime < 72 hours) && (borrower.collateral != 0)) revert AuctionNotClearable();  ==>          if ((block.timestamp - kickTime < 72 minutes) && (borrower.collateral != 0)) revert AuctionNotClearable();...VALID [written to mutants/Auctions/Auctions.mutant.130.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth != 0 && borrower.t0Debt >= 0 && borrower.collateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.131.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth > 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.132.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth != 0 && borrower.t0Debt > 0 && borrower.collateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.133.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral > 0) {...VALID [written to mutants/Auctions/Auctions.mutant.134.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth != 0 && borrower.t0Debt != 1 && borrower.collateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.135.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth != 0 && borrower.t0Debt != (0+1) && borrower.collateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.136.sol] 
PROCESSING MUTANT: 216:         while (params_.bucketDepth != 0 && borrower.t0Debt != 0 && borrower.collateral != 0) {  ==>          while (params_.bucketDepth != 0 && (1==1) && borrower.collateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.137.sol] 
PROCESSING MUTANT: 219:             (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);  ==>              (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, (1+1));...VALID [written to mutants/Auctions/Auctions.mutant.138.sol] 
PROCESSING MUTANT: 223:             if (vars.unscaledDeposit != 0) {  ==>              if (vars.unscaledDeposit > 0) {...VALID [written to mutants/Auctions/Auctions.mutant.139.sol] 
PROCESSING MUTANT: 224:                 vars.debt              = Maths.wmul(borrower.t0Debt, params_.inflator);       // current debt to be settled  ==>                  vars.debt              = Maths.wmul( params_.inflator,borrower.t0Debt);       // current debt to be settled...VALID [written to mutants/Auctions/Auctions.mutant.140.sol] 
PROCESSING MUTANT: 224:                 vars.debt              = Maths.wmul(borrower.t0Debt, params_.inflator);       // current debt to be settled  ==>                  vars.debt              = Maths.wmul(borrower.t0Debt, params_.inflator);       //  debt to be settled...VALID [written to mutants/Auctions/Auctions.mutant.141.sol] 
PROCESSING MUTANT: 225:                 vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         // max debt that can be settled with existing collateral  ==>                  vars.maxSettleableDebt = Maths.wmul( vars.price,borrower.collateral);         // max debt that can be settled with existing collateral...VALID [written to mutants/Auctions/Auctions.mutant.142.sol] 
PROCESSING MUTANT: 225:                 vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         // max debt that can be settled with existing collateral  ==>                  vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         // min debt that can be settled with existing collateral...VALID [written to mutants/Auctions/Auctions.mutant.143.sol] 
PROCESSING MUTANT: 225:                 vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         // max debt that can be settled with existing collateral  ==>                  vars.maxSettleableDebt = Maths.wmul(borrower.collateral, vars.price);         //  debt that can be settled with existing collateral...VALID [written to mutants/Auctions/Auctions.mutant.144.sol] 
PROCESSING MUTANT: 226:                 vars.scaledDeposit     = Maths.wmul(vars.scale, vars.unscaledDeposit);  ==>                  vars.scaledDeposit     = Maths.wmul( vars.unscaledDeposit,vars.scale);...VALID [written to mutants/Auctions/Auctions.mutant.145.sol] 
PROCESSING MUTANT: 229:                 if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {  ==>                  if (vars.scaledDeposit > vars.debt && vars.maxSettleableDebt >= vars.debt) {...VALID [written to mutants/Auctions/Auctions.mutant.146.sol] 
PROCESSING MUTANT: 229:                 if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt >= vars.debt) {  ==>                  if (vars.scaledDeposit >= vars.debt && vars.maxSettleableDebt > vars.debt) {...VALID [written to mutants/Auctions/Auctions.mutant.147.sol] 
PROCESSING MUTANT: 230:                     borrower.t0Debt      = 0;                                                 // no remaining debt to settle  ==>                      borrower.t0Debt      = 0;                                                 //  remaining debt to settle...VALID [written to mutants/Auctions/Auctions.mutant.148.sol] 
PROCESSING MUTANT: 232:                     vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);                 // remove only what's needed to settle the debt  ==>                      vars.unscaledDeposit = Maths.wdiv(vars.debt, vars.scale);                 //  only what's needed to settle the debt...VALID [written to mutants/Auctions/Auctions.mutant.149.sol] 
PROCESSING MUTANT: 237:                 else if (vars.maxSettleableDebt >= vars.scaledDeposit) {  ==>                  else if (vars.maxSettleableDebt > vars.scaledDeposit) {...VALID [written to mutants/Auctions/Auctions.mutant.150.sol] 
PROCESSING MUTANT: 238:                     borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t1 amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.151.sol] 
PROCESSING MUTANT: 238:                     borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t-1 amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.152.sol] 
PROCESSING MUTANT: 238:                     borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t(0+1) amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.153.sol] 
PROCESSING MUTANT: 238:                     borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t(0-1) amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.154.sol] 
PROCESSING MUTANT: 238:                     borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  // subtract from debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt     -= Maths.wdiv(vars.scaledDeposit, params_.inflator);  //  from debt the corresponding t0 amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.155.sol] 
PROCESSING MUTANT: 251:                 borrower.collateral             -= vars.collateralUsed;               // move settled collateral from loan into bucket  ==>                  borrower.collateral             -= vars.collateralUsed;               // move settled collateral from loan uinto bucket...VALID [written to mutants/Auctions/Auctions.mutant.156.sol] 
PROCESSING MUTANT: 251:                 borrower.collateral             -= vars.collateralUsed;               // move settled collateral from loan into bucket  ==>                  borrower.collateral             -= vars.collateralUsed;               //  settled collateral from loan into bucket...VALID [written to mutants/Auctions/Auctions.mutant.157.sol] 
PROCESSING MUTANT: 254:                 Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit); // remove amount to settle debt from bucket (could be entire deposit or only the settled debt)  ==>                  Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit); //  amount to settle debt from bucket (could be entire deposit or only the settled debt)...VALID [written to mutants/Auctions/Auctions.mutant.158.sol] 
PROCESSING MUTANT: 262:                     0,  // zero deposit in bucket  ==>                      1,  // zero deposit in bucket...VALID [written to mutants/Auctions/Auctions.mutant.159.sol] 
PROCESSING MUTANT: 262:                     0,  // zero deposit in bucket  ==>                      (0+1),  // zero deposit in bucket...VALID [written to mutants/Auctions/Auctions.mutant.160.sol] 
PROCESSING MUTANT: 262:                     0,  // zero deposit in bucket  ==>                      0,  //  deposit in bucket...VALID [written to mutants/Auctions/Auctions.mutant.161.sol] 
                break;...VALID [written to mutants/Auctions/Auctions.mutant.162.sol] 
                continue;...VALID [written to mutants/Auctions/Auctions.mutant.163.sol] 
PROCESSING MUTANT: 266:                 borrower.collateral = 0; // entire collateral added into bucket  ==>                  borrower.collateral = 0; // entire collateral added uinto bucket...VALID [written to mutants/Auctions/Auctions.mutant.164.sol] 
PROCESSING MUTANT: 266:                 borrower.collateral = 0; // entire collateral added into bucket  ==>                  borrower.collateral = 0; //  collateral added into bucket...VALID [written to mutants/Auctions/Auctions.mutant.165.sol] 
            continue;...VALID [written to mutants/Auctions/Auctions.mutant.166.sol] 
PROCESSING MUTANT: 273:         if (borrower.t0Debt != 0 && borrower.collateral == 0) {  ==>          if (borrower.t0Debt >= 0 && borrower.collateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.167.sol] 
PROCESSING MUTANT: 273:         if (borrower.t0Debt != 0 && borrower.collateral == 0) {  ==>          if (borrower.t0Debt > 0 && borrower.collateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.168.sol] 
PROCESSING MUTANT: 273:         if (borrower.t0Debt != 0 && borrower.collateral == 0) {  ==>          if (borrower.t0Debt != 0 && borrower.collateral <= 0) {...VALID [written to mutants/Auctions/Auctions.mutant.169.sol] 
PROCESSING MUTANT: 273:         if (borrower.t0Debt != 0 && borrower.collateral == 0) {  ==>          if (borrower.t0Debt != 1 && borrower.collateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.170.sol] 
PROCESSING MUTANT: 273:         if (borrower.t0Debt != 0 && borrower.collateral == 0) {  ==>          if (borrower.t0Debt != (0+1) && borrower.collateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.171.sol] 
PROCESSING MUTANT: 273:         if (borrower.t0Debt != 0 && borrower.collateral == 0) {  ==>          if ((1==1) && borrower.collateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.172.sol] 
PROCESSING MUTANT: 279:             while (params_.bucketDepth != 0 && borrower.t0Debt != 0) {  ==>              while (params_.bucketDepth > 0 && borrower.t0Debt != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.173.sol] 
PROCESSING MUTANT: 279:             while (params_.bucketDepth != 0 && borrower.t0Debt != 0) {  ==>              while (params_.bucketDepth != 0 && borrower.t0Debt > 0) {...VALID [written to mutants/Auctions/Auctions.mutant.174.sol] 
PROCESSING MUTANT: 282:                 (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, 1);  ==>                  (vars.index, , vars.scale) = Deposits.findIndexAndSumOfSum(deposits_, (1+1));...VALID [written to mutants/Auctions/Auctions.mutant.175.sol] 
PROCESSING MUTANT: 284:                 vars.depositToRemove = Maths.wmul(vars.scale, vars.unscaledDeposit);  ==>                  vars.depositToRemove = Maths.wmul( vars.unscaledDeposit,vars.scale);...VALID [written to mutants/Auctions/Auctions.mutant.176.sol] 
PROCESSING MUTANT: 285:                 vars.debt            = Maths.wmul(borrower.t0Debt, params_.inflator);  ==>                  vars.debt            = Maths.wmul( params_.inflator,borrower.t0Debt);...VALID [written to mutants/Auctions/Auctions.mutant.177.sol] 
PROCESSING MUTANT: 288:                 if (vars.depositToRemove >= vars.debt) {  ==>                  if (vars.depositToRemove > vars.debt) {...VALID [written to mutants/Auctions/Auctions.mutant.178.sol] 
                    break;...VALID [written to mutants/Auctions/Auctions.mutant.179.sol] 
                    continue;...VALID [written to mutants/Auctions/Auctions.mutant.180.sol] 
PROCESSING MUTANT: 290:                     borrower.t0Debt  = 0;                                                              // no remaining debt to settle  ==>                      borrower.t0Debt  = 0;                                                              //  remaining debt to settle...VALID [written to mutants/Auctions/Auctions.mutant.181.sol] 
PROCESSING MUTANT: 294:                     borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t1 amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.182.sol] 
PROCESSING MUTANT: 294:                     borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t-1 amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.183.sol] 
PROCESSING MUTANT: 294:                     borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t(0+1) amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.184.sol] 
PROCESSING MUTANT: 294:                     borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t(0-1) amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.185.sol] 
PROCESSING MUTANT: 294:                     borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             // subtract from remaining debt the corresponding t0 amount of deposit  ==>                      borrower.t0Debt -= Maths.wdiv(vars.depositToRemove, params_.inflator);             //  from remaining debt the corresponding t0 amount of deposit...VALID [written to mutants/Auctions/Auctions.mutant.186.sol] 
PROCESSING MUTANT: 296:                     Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);              // Remove all deposit from bucket  ==>                      Deposits.unscaledRemove(deposits_, vars.index, vars.unscaledDeposit);              //  all deposit from bucket...VALID [written to mutants/Auctions/Auctions.mutant.187.sol] 
PROCESSING MUTANT: 299:                     if (hpbBucket.collateral == 0) {                                                   // existing LPs for the bucket shall become unclaimable.  ==>                      if (hpbBucket.collateral <= 0) {                                                   // existing LPs for the bucket shall become unclaimable....VALID [written to mutants/Auctions/Auctions.mutant.188.sol] 
PROCESSING MUTANT: 299:                     if (hpbBucket.collateral == 0) {                                                   // existing LPs for the bucket shall become unclaimable.  ==>                      if (hpbBucket.collateral == 0) {                                                   //  LPs for the bucket shall become unclaimable....VALID [written to mutants/Auctions/Auctions.mutant.189.sol] 
PROCESSING MUTANT: 300:                         emit BucketBankruptcy(vars.index, hpbBucket.lps);  ==>                          emit BucketBankruptcy( hpbBucket.lps,vars.index);...VALID [written to mutants/Auctions/Auctions.mutant.190.sol] 
PROCESSING MUTANT: 300:                         emit BucketBankruptcy(vars.index, hpbBucket.lps);  ==>                          /*emit BucketBankruptcy(vars.index, hpbBucket.lps);*/...VALID [written to mutants/Auctions/Auctions.mutant.191.sol] 
                continue;...VALID [written to mutants/Auctions/Auctions.mutant.192.sol] 
PROCESSING MUTANT: 314:         if (borrower.t0Debt == 0) {  ==>          if (borrower.t0Debt <= 0) {...VALID [written to mutants/Auctions/Auctions.mutant.193.sol] 
PROCESSING MUTANT: 358:             0  ==>              1...VALID [written to mutants/Auctions/Auctions.mutant.194.sol] 
PROCESSING MUTANT: 358:             0  ==>              (0+1)...VALID [written to mutants/Auctions/Auctions.mutant.195.sol] 
PROCESSING MUTANT: 392:         if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLPs = lender.lps;  ==>          if (bucket.bankruptcyTime <= lender.depositTime) vars.lenderLPs = lender.lps;...VALID [written to mutants/Auctions/Auctions.mutant.196.sol] 
PROCESSING MUTANT: 392:         if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLPs = lender.lps;  ==>          if (bucket.bankruptcyTime != lender.depositTime) vars.lenderLPs = lender.lps;...VALID [written to mutants/Auctions/Auctions.mutant.197.sol] 
PROCESSING MUTANT: 392:         if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLPs = lender.lps;  ==>          if (true) vars.lenderLPs = lender.lps;...VALID [written to mutants/Auctions/Auctions.mutant.198.sol] 
PROCESSING MUTANT: 392:         if (bucket.bankruptcyTime < lender.depositTime) vars.lenderLPs = lender.lps;  ==>          if (1==1) vars.lenderLPs = lender.lps;...VALID [written to mutants/Auctions/Auctions.mutant.199.sol] 
PROCESSING MUTANT: 399:         vars.bucketDeposit         = Maths.wmul(vars.bucketUnscaledDeposit, vars.bucketScale);  ==>          vars.bucketDeposit         = Maths.wmul( vars.bucketScale,vars.bucketUnscaledDeposit);...VALID [written to mutants/Auctions/Auctions.mutant.200.sol] 
PROCESSING MUTANT: 409:         vars.amountToDebitFromDeposit = Maths.wmul(vars.lenderLPs, vars.bucketRate);  // calculate amount to remove based on lender LPs in bucket  ==>          vars.amountToDebitFromDeposit = Maths.wmul( vars.bucketRate,vars.lenderLPs);  // calculate amount to remove based on lender LPs in bucket...VALID [written to mutants/Auctions/Auctions.mutant.201.sol] 
PROCESSING MUTANT: 409:         vars.amountToDebitFromDeposit = Maths.wmul(vars.lenderLPs, vars.bucketRate);  // calculate amount to remove based on lender LPs in bucket  ==>          vars.amountToDebitFromDeposit = Maths.wmul(vars.lenderLPs, vars.bucketRate);  // calculate amount to remove based on lbeginer LPs in bucket...VALID [written to mutants/Auctions/Auctions.mutant.202.sol] 
PROCESSING MUTANT: 409:         vars.amountToDebitFromDeposit = Maths.wmul(vars.lenderLPs, vars.bucketRate);  // calculate amount to remove based on lender LPs in bucket  ==>          vars.amountToDebitFromDeposit = Maths.wmul(vars.lenderLPs, vars.bucketRate);  //  amount to remove based on lender LPs in bucket...VALID [written to mutants/Auctions/Auctions.mutant.203.sol] 
PROCESSING MUTANT: 411:         if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit...VALID [written to mutants/Auctions/Auctions.mutant.204.sol] 
PROCESSING MUTANT: 411:         if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit  ==>          if (vars.amountToDebitFromDeposit >= vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit...VALID [written to mutants/Auctions/Auctions.mutant.205.sol] 
PROCESSING MUTANT: 411:         if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit  ==>          if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; //  the amount to remove at bucket deposit...VALID [written to mutants/Auctions/Auctions.mutant.206.sol] 
PROCESSING MUTANT: 411:         if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit  ==>          if (false) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit...VALID [written to mutants/Auctions/Auctions.mutant.207.sol] 
PROCESSING MUTANT: 411:         if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit  ==>          /*if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit*/...VALID [written to mutants/Auctions/Auctions.mutant.208.sol] 
PROCESSING MUTANT: 411:         if (vars.amountToDebitFromDeposit > vars.bucketDeposit) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit  ==>          if (0==1) vars.amountToDebitFromDeposit = vars.bucketDeposit; // cap the amount to remove at bucket deposit...VALID [written to mutants/Auctions/Auctions.mutant.209.sol] 
PROCESSING MUTANT: 414:         if (vars.amountToDebitFromDeposit == 0) revert InsufficientLiquidity();  ==>          if (vars.amountToDebitFromDeposit <= 0) revert InsufficientLiquidity();...VALID [written to mutants/Auctions/Auctions.mutant.210.sol] 
PROCESSING MUTANT: 428:         if (vars.amountToDebitFromDeposit > kickResult_.amountToCoverBond) {  ==>          if (vars.amountToDebitFromDeposit >= kickResult_.amountToCoverBond) {...VALID [written to mutants/Auctions/Auctions.mutant.211.sol] 
PROCESSING MUTANT: 429:             vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;                      // cap amount to remove from deposit at amount to cover bond  ==>              vars.amountToDebitFromDeposit = kickResult_.amountToCoverBond;                      //  amount to remove from deposit at amount to cover bond...VALID [written to mutants/Auctions/Auctions.mutant.212.sol] 
PROCESSING MUTANT: 431:             kickResult_.lup = _lup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit); // recalculate the LUP with the amount to cover bond  ==>              kickResult_.lup = _lup(deposits_, poolState_.debt + vars.amountToDebitFromDeposit); //  the LUP with the amount to cover bond...VALID [written to mutants/Auctions/Auctions.mutant.213.sol] 
PROCESSING MUTANT: 432:             kickResult_.amountToCoverBond = 0;                                                  // entire bond is covered from deposit, no additional amount to be send by lender  ==>              kickResult_.amountToCoverBond = 0;                                                  // entire bond is covered from deposit, no additional amount to be sbegin by lender...VALID [written to mutants/Auctions/Auctions.mutant.214.sol] 
PROCESSING MUTANT: 432:             kickResult_.amountToCoverBond = 0;                                                  // entire bond is covered from deposit, no additional amount to be send by lender  ==>              kickResult_.amountToCoverBond = 0;                                                  //  bond is covered from deposit, no additional amount to be send by lender...VALID [written to mutants/Auctions/Auctions.mutant.215.sol] 
PROCESSING MUTANT: 434:             kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;                     // lender should send additional amount to cover bond  ==>              kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;                     // lbeginer should send additional amount to cover bond...VALID [written to mutants/Auctions/Auctions.mutant.216.sol] 
PROCESSING MUTANT: 434:             kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;                     // lender should send additional amount to cover bond  ==>              kickResult_.amountToCoverBond -= vars.amountToDebitFromDeposit;                     //  should send additional amount to cover bond...VALID [written to mutants/Auctions/Auctions.mutant.217.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral != 0) {...VALID [written to mutants/Auctions/Auctions.mutant.218.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral <= 0) {...VALID [written to mutants/Auctions/Auctions.mutant.219.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit >= vars.bucketDeposit && vars.bucketCollateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.220.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral >= 0) {...VALID [written to mutants/Auctions/Auctions.mutant.221.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit > vars.bucketDeposit && vars.bucketCollateral == 0) {...VALID [written to mutants/Auctions/Auctions.mutant.222.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral > 0) {...VALID [written to mutants/Auctions/Auctions.mutant.223.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral < 0) {...VALID [written to mutants/Auctions/Auctions.mutant.224.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 1) {...VALID [written to mutants/Auctions/Auctions.mutant.225.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == (0+1)) {...VALID [written to mutants/Auctions/Auctions.mutant.226.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (false) {...VALID [written to mutants/Auctions/Auctions.mutant.227.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (0==1) {...VALID [written to mutants/Auctions/Auctions.mutant.228.sol] 
PROCESSING MUTANT: 441:         if (vars.amountToDebitFromDeposit == vars.bucketDeposit && vars.bucketCollateral == 0) {  ==>          if (vars.amountToDebitFromDeposit == vars.bucketDeposit && (1==1)) {...VALID [written to mutants/Auctions/Auctions.mutant.229.sol] 
PROCESSING MUTANT: 461:         emit RemoveQuoteToken(msg.sender, index_, vars.amountToDebitFromDeposit, vars.redeemedLPs, kickResult_.lup);  ==>          emit RemoveQuoteToken(msg.sender, index_, vars.redeemedLPs, vars.amountToDebitFromDeposit, kickResult_.lup);...VALID [written to mutants/Auctions/Auctions.mutant.230.sol] 
PROCESSING MUTANT: 484:         Borrower memory borrower = loans_.borrowers[borrowerAddress_];  ==>          Borrower storage borrower = loans_.borrowers[borrowerAddress_];...VALID [written to mutants/Auctions/Auctions.mutant.231.sol] 
PROCESSING MUTANT: 486:         if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0  ==>          if (borrower.collateral <= 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0...VALID [written to mutants/Auctions/Auctions.mutant.232.sol] 
PROCESSING MUTANT: 486:         if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0  ==>          if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 1...VALID [written to mutants/Auctions/Auctions.mutant.233.sol] 
PROCESSING MUTANT: 486:         if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0  ==>          if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is -1...VALID [written to mutants/Auctions/Auctions.mutant.234.sol] 
PROCESSING MUTANT: 486:         if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0  ==>          if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is (0+1)...VALID [written to mutants/Auctions/Auctions.mutant.235.sol] 
PROCESSING MUTANT: 486:         if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0  ==>          if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is (0-1)...VALID [written to mutants/Auctions/Auctions.mutant.236.sol] 
PROCESSING MUTANT: 486:         if (borrower.collateral == 0) revert InsufficientCollateral(); // revert if borrower's collateral is 0  ==>          if (borrower.collateral == 0) revert InsufficientCollateral(); //  if borrower's collateral is 0...VALID [written to mutants/Auctions/Auctions.mutant.237.sol] 
PROCESSING MUTANT: 512:         poolState_.debt   = Maths.wmul(poolState_.t0Debt, poolState_.inflator);  ==>          poolState_.debt   = Maths.wmul( poolState_.inflator,poolState_.t0Debt);...VALID [written to mutants/Auctions/Auctions.mutant.238.sol] 
PROCESSING MUTANT: 552:         if (collateral_ == 0) revert InvalidAmount();  ==>          if (collateral_ <= 0) revert InvalidAmount();...VALID [written to mutants/Auctions/Auctions.mutant.239.sol] 
PROCESSING MUTANT: 554:         Borrower memory borrower = loans_.borrowers[borrowerAddress_];  ==>          Borrower storage borrower = loans_.borrowers[borrowerAddress_];...VALID [written to mutants/Auctions/Auctions.mutant.240.sol] 
PROCESSING MUTANT: 557:             (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) || // revert in case of NFT take when there isn't a full token to be taken  ==>              (poolState_.poolType >= uint8(PoolType.ERC721) && borrower.collateral < 1e18) || // revert in case of NFT take when there isn't a full token to be taken...VALID [written to mutants/Auctions/Auctions.mutant.241.sol] 
PROCESSING MUTANT: 557:             (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) || // revert in case of NFT take when there isn't a full token to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral <= 1e18) || // revert in case of NFT take when there isn't a full token to be taken...VALID [written to mutants/Auctions/Auctions.mutant.242.sol] 
PROCESSING MUTANT: 557:             (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) || // revert in case of NFT take when there isn't a full token to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e0) || // revert in case of NFT take when there isn't a full token to be taken...VALID [written to mutants/Auctions/Auctions.mutant.243.sol] 
PROCESSING MUTANT: 557:             (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) || // revert in case of NFT take when there isn't a full token to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e1) || // revert in case of NFT take when there isn't a full token to be taken...VALID [written to mutants/Auctions/Auctions.mutant.244.sol] 
PROCESSING MUTANT: 557:             (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) || // revert in case of NFT take when there isn't a full token to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC721) && borrower.collateral < 1e18) || //  in case of NFT take when there isn't a full token to be taken...VALID [written to mutants/Auctions/Auctions.mutant.245.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType <= uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.246.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral <= 0)      // revert in case of ERC20 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.247.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType >= uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.248.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC0 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.249.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC1 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.250.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC-1 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.251.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC(20+1) take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.252.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC(20-1) take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.253.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      //  in case of ERC20 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.254.sol] 
PROCESSING MUTANT: 558:             (poolState_.poolType == uint8(PoolType.ERC20)  && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken  ==>              ((1==1) && borrower.collateral == 0)      // revert in case of ERC20 take when no collateral to be taken...VALID [written to mutants/Auctions/Auctions.mutant.255.sol] 
PROCESSING MUTANT: 585:         poolState_.debt   = Maths.wmul(poolState_.t0Debt, poolState_.inflator);  ==>          poolState_.debt   = Maths.wmul( poolState_.inflator,poolState_.t0Debt);...VALID [written to mutants/Auctions/Auctions.mutant.256.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp / 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.257.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp % 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.258.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp + reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.259.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked == 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.260.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked < 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.261.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp == lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.262.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp <= lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.263.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 0 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.264.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 0 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.265.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 1 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.266.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 1 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.267.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks && block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.268.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 seconds || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.269.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 seconds) {...VALID [written to mutants/Auctions/Auctions.mutant.270.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 minutes || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.271.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 minutes) {...VALID [written to mutants/Auctions/Auctions.mutant.272.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 days || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.273.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 hours || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.274.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2  || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.275.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if (block.timestamp < lastBurnTimestamp + 2 weeks || (0==1)) {...VALID [written to mutants/Auctions/Auctions.mutant.276.sol] 
PROCESSING MUTANT: 628:         if (block.timestamp < lastBurnTimestamp + 2 weeks || block.timestamp - reserveAuction_.kicked <= 72 hours) {  ==>          if ((0==1) || block.timestamp - reserveAuction_.kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.277.sol] 
PROCESSING MUTANT: 635:             Maths.wmul(params_.t0PoolDebt, params_.inflator),  ==>              Maths.wmul( params_.inflator,params_.t0PoolDebt),...VALID [written to mutants/Auctions/Auctions.mutant.278.sol] 
PROCESSING MUTANT: 642:         kickerAward_ = Maths.wmul(0.01 * 1e18, claimable);  ==>          kickerAward_ = Maths.wmul( claimable,0.01 * 1e18);...VALID [written to mutants/Auctions/Auctions.mutant.279.sol] 
PROCESSING MUTANT: 646:         if (curUnclaimedAuctionReserve == 0) revert NoReserves();  ==>          if (curUnclaimedAuctionReserve <= 0) revert NoReserves();...VALID [written to mutants/Auctions/Auctions.mutant.280.sol] 
PROCESSING MUTANT: 678:         if (maxAmount_ == 0) revert InvalidAmount();  ==>          if (maxAmount_ <= 0) revert InvalidAmount();...VALID [written to mutants/Auctions/Auctions.mutant.281.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if (kicked != 0 && block.timestamp % kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.282.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if (kicked >= 0 && block.timestamp - kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.283.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if (kicked > 0 && block.timestamp - kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.284.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if (kicked != 0 && block.timestamp - kicked < 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.285.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if (kicked != 1 && block.timestamp - kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.286.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if (kicked != (0+1) && block.timestamp - kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.287.sol] 
PROCESSING MUTANT: 682:         if (kicked != 0 && block.timestamp - kicked <= 72 hours) {  ==>          if ((1==1) && block.timestamp - kicked <= 72 hours) {...VALID [written to mutants/Auctions/Auctions.mutant.288.sol] 
PROCESSING MUTANT: 686:             amount_       = Maths.min(unclaimed, maxAmount_);  ==>              amount_       = Maths.min( maxAmount_,unclaimed);...VALID [written to mutants/Auctions/Auctions.mutant.289.sol] 
PROCESSING MUTANT: 687:             ajnaRequired_ = Maths.wmul(amount_, price);  ==>              ajnaRequired_ = Maths.wmul( price,amount_);...VALID [written to mutants/Auctions/Auctions.mutant.290.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       +  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.291.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       -  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.292.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       /  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.293.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       %  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.294.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC0 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.295.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC1 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.296.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC-1 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.297.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC(20+1) pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.298.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC(20-1) pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.299.sol] 
     break;...VALID [written to mutants/Auctions/Auctions.mutant.300.sol] 
     continue;...VALID [written to mutants/Auctions/Auctions.mutant.301.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled ( rounded collateral for NFT pool,same amount for ERC20 pool)....VALID [written to mutants/Auctions/Auctions.mutant.302.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_    remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.303.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral  after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.304.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining  auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.305.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after  is settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.306.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction  settled (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.307.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is  (same amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.308.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled  amount for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.309.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same  for ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.310.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount  ERC20 pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.311.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for  pool, rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.312.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20  rounded collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.313.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool,  collateral for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.314.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded  for NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.315.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral  NFT pool)....VALID [written to mutants/Auctions/Auctions.mutant.316.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for  pool)....VALID [written to mutants/Auctions/Auctions.mutant.317.sol] 
PROCESSING MUTANT: 722:      *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT pool).  ==>       *  @return remainingCollateral_   Collateral remaining after auction is settled (same amount for ERC20 pool, rounded collateral for NFT ...VALID [written to mutants/Auctions/Auctions.mutant.318.sol] 
PROCESSING MUTANT: 734:         if (poolType_ == uint8(PoolType.ERC721)) {  ==>          if (poolType_ >= uint8(PoolType.ERC721)) {...VALID [written to mutants/Auctions/Auctions.mutant.319.sol] 
PROCESSING MUTANT: 738:             remainingCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD; // floor collateral of borrower  ==>              remainingCollateral_ = (borrowerCollateral_ / Maths.WAD) * Maths.WAD; //  collateral of borrower...VALID [written to mutants/Auctions/Auctions.mutant.320.sol] 
PROCESSING MUTANT: 741:             if (remainingCollateral_ != borrowerCollateral_) {  ==>              if (remainingCollateral_ <= borrowerCollateral_) {...VALID [written to mutants/Auctions/Auctions.mutant.321.sol] 
PROCESSING MUTANT: 741:             if (remainingCollateral_ != borrowerCollateral_) {  ==>              if (remainingCollateral_ < borrowerCollateral_) {...VALID [written to mutants/Auctions/Auctions.mutant.322.sol] 
PROCESSING MUTANT: 741:             if (remainingCollateral_ != borrowerCollateral_) {  ==>              if (true) {...VALID [written to mutants/Auctions/Auctions.mutant.323.sol] 
PROCESSING MUTANT: 741:             if (remainingCollateral_ != borrowerCollateral_) {  ==>              if (1==1) {...VALID [written to mutants/Auctions/Auctions.mutant.324.sol] 
PROCESSING MUTANT: 753:                 bucketIndex = auctionPrice > MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;  ==>                  bucketIndex = auctionPrice >= MIN_PRICE ? _indexOf(auctionPrice) : MAX_FENWICK_INDEX;...VALID [written to mutants/Auctions/Auctions.mutant.325.sol] 
PROCESSING MUTANT: 765:             emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, lps, bucketIndex);  ==>              emit AuctionNFTSettle(borrowerAddress_, lps, remainingCollateral_, bucketIndex);...VALID [written to mutants/Auctions/Auctions.mutant.326.sol] 
PROCESSING MUTANT: 765:             emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, lps, bucketIndex);  ==>              emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, bucketIndex, lps);...VALID [written to mutants/Auctions/Auctions.mutant.327.sol] 
PROCESSING MUTANT: 765:             emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, lps, bucketIndex);  ==>              /*emit AuctionNFTSettle(borrowerAddress_, remainingCollateral_, lps, bucketIndex);*/...VALID [written to mutants/Auctions/Auctions.mutant.328.sol] 
PROCESSING MUTANT: 817:         vars.borrowerDebt       = Maths.wmul(kickResult_.t0KickedDebt, poolState_.inflator);  ==>          vars.borrowerDebt       = Maths.wmul( poolState_.inflator,kickResult_.t0KickedDebt);...VALID [written to mutants/Auctions/Auctions.mutant.329.sol] 
PROCESSING MUTANT: 821:         if (_isCollateralized(vars.borrowerDebt, vars.borrowerCollateral, kickResult_.lup, poolState_.poolType)) {  ==>          if (_isCollateralized(vars.borrowerDebt, kickResult_.lup, vars.borrowerCollateral, poolState_.poolType)) {...VALID [written to mutants/Auctions/Auctions.mutant.330.sol] 
PROCESSING MUTANT: 826:         vars.neutralPrice = Maths.wmul(borrower.t0Np, poolState_.inflator);  ==>          vars.neutralPrice = Maths.wmul( poolState_.inflator,borrower.t0Np);...VALID [written to mutants/Auctions/Auctions.mutant.331.sol] 
PROCESSING MUTANT: 864:         vars.kickPenalty   = Maths.wmul(vars.t0KickPenalty, poolState_.inflator);  ==>          vars.kickPenalty   = Maths.wmul( poolState_.inflator,vars.t0KickPenalty);...VALID [written to mutants/Auctions/Auctions.mutant.332.sol] 
PROCESSING MUTANT: 909:         if (params_.poolType == uint8(PoolType.ERC721)) {  ==>          if (params_.poolType >= uint8(PoolType.ERC721)) {...VALID [written to mutants/Auctions/Auctions.mutant.333.sol] 
PROCESSING MUTANT: 917:             Maths.min(takeableCollateral, params_.takeCollateral),  ==>              Maths.min( params_.takeCollateral,takeableCollateral),...VALID [written to mutants/Auctions/Auctions.mutant.334.sol] 
PROCESSING MUTANT: 933:         if (params_.poolType == uint8(PoolType.ERC721)) {  ==>          if (params_.poolType >= uint8(PoolType.ERC721)) {...VALID [written to mutants/Auctions/Auctions.mutant.335.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 + 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.336.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 - 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.337.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 * 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.338.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 % 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.339.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 0.5 it will be 2.5 / 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.340.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 1.5 it will be 2.5 / 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.341.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if -1.5 it will be 2.5 / 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.342.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if (2+1).5 it will be 2.5 / 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.343.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if (2-1).5 it will be 2.5 / 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.344.sol] 
PROCESSING MUTANT: 935:             uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; // solidity rounds down, so if 2.5 it will be 2.5 / 1 = 2  ==>              uint256 collateralTaken = (vars_.collateralAmount / 1e18) * 1e18; //  rounds down, so if 2.5 it will be 2.5 / 1 = 2...VALID [written to mutants/Auctions/Auctions.mutant.345.sol] 
PROCESSING MUTANT: 937:             if (collateralTaken != vars_.collateralAmount) { // collateral taken not a round number  ==>              if (collateralTaken < vars_.collateralAmount) { // collateral taken not a round number...VALID [written to mutants/Auctions/Auctions.mutant.346.sol] 
PROCESSING MUTANT: 937:             if (collateralTaken != vars_.collateralAmount) { // collateral taken not a round number  ==>              if (collateralTaken != vars_.collateralAmount) { //  taken not a round number...VALID [written to mutants/Auctions/Auctions.mutant.347.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken / 1e18) {...VALID [written to mutants/Auctions/Auctions.mutant.348.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken % 1e18) {...VALID [written to mutants/Auctions/Auctions.mutant.349.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) == collateralTaken + 1e18) {...VALID [written to mutants/Auctions/Auctions.mutant.350.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) <= collateralTaken + 1e18) {...VALID [written to mutants/Auctions/Auctions.mutant.351.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 0e18) {...VALID [written to mutants/Auctions/Auctions.mutant.352.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e0) {...VALID [written to mutants/Auctions/Auctions.mutant.353.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e1) {...VALID [written to mutants/Auctions/Auctions.mutant.354.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.min( params_.takeCollateral,borrower_.collateral) >= collateralTaken + 1e18) {...VALID [written to mutants/Auctions/Auctions.mutant.355.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (Maths.max(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {...VALID [written to mutants/Auctions/Auctions.mutant.356.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (true) {...VALID [written to mutants/Auctions/Auctions.mutant.357.sol] 
PROCESSING MUTANT: 938:                 if (Maths.min(borrower_.collateral, params_.takeCollateral) >= collateralTaken + 1e18) {  ==>                  if (1==1) {...VALID [written to mutants/Auctions/Auctions.mutant.358.sol] 
PROCESSING MUTANT: 939:                     collateralTaken += 1e18; // round up collateral to take  ==>                      collateralTaken += 1e18; //  up collateral to take...VALID [written to mutants/Auctions/Auctions.mutant.359.sol] 
PROCESSING MUTANT: 942:                     vars_.excessQuoteToken = Maths.wmul(collateralTaken - vars_.collateralAmount, vars_.auctionPrice);  ==>                      vars_.excessQuoteToken = Maths.wmul( vars_.auctionPrice,collateralTaken - vars_.collateralAmount);...VALID [written to mutants/Auctions/Auctions.mutant.360.sol] 
PROCESSING MUTANT: 946:                     revert CollateralRoundingNeededButNotPossible();  ==>  revert();...VALID [written to mutants/Auctions/Auctions.mutant.361.sol] 
PROCESSING MUTANT: 946:                     revert CollateralRoundingNeededButNotPossible();  ==>                      /*revert CollateralRoundingNeededButNotPossible();*/...VALID [written to mutants/Auctions/Auctions.mutant.362.sol] 
PROCESSING MUTANT: 978:         if (vars_.unscaledDeposit == 0) revert InsufficientLiquidity(); // revert if no quote tokens in arbed bucket  ==>          if (vars_.unscaledDeposit <= 0) revert InsufficientLiquidity(); // revert if no quote tokens in arbed bucket...VALID [written to mutants/Auctions/Auctions.mutant.363.sol] 
PROCESSING MUTANT: 978:         if (vars_.unscaledDeposit == 0) revert InsufficientLiquidity(); // revert if no quote tokens in arbed bucket  ==>          if (vars_.unscaledDeposit == 0) revert InsufficientLiquidity(); //  if no quote tokens in arbed bucket...VALID [written to mutants/Auctions/Auctions.mutant.364.sol] 
PROCESSING MUTANT: 983:         if (vars_.auctionPrice > vars_.bucketPrice) revert AuctionPriceGtBucketPrice();  ==>          if (vars_.auctionPrice >= vars_.bucketPrice) revert AuctionPriceGtBucketPrice();...VALID [written to mutants/Auctions/Auctions.mutant.365.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       +  @return newLup_                The new LUP of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.366.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       -  @return newLup_                The new LUP of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.367.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       /  @return newLup_                The new LUP of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.368.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       %  @return newLup_                The new LUP of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.369.sol] 
     break;...VALID [written to mutants/Auctions/Auctions.mutant.370.sol] 
     continue;...VALID [written to mutants/Auctions/Auctions.mutant.371.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                 new LUP of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.372.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The  LUP of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.373.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new  of pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.374.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new LUP  pool (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.375.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new LUP of  (after debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.376.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new LUP of pool  debt is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.377.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new LUP of pool (after  is repaid)....VALID [written to mutants/Auctions/Auctions.mutant.378.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new LUP of pool (after debt  repaid)....VALID [written to mutants/Auctions/Auctions.mutant.379.sol] 
PROCESSING MUTANT: 1025:      *  @return newLup_                The new LUP of pool (after debt is repaid).  ==>       *  @return newLup_                The new LUP of pool (after debt is ...VALID [written to mutants/Auctions/Auctions.mutant.380.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       +  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.381.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       -  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.382.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       /  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.383.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       %  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.384.sol] 
     break;...VALID [written to mutants/Auctions/Auctions.mutant.385.sol] 
     continue;...VALID [written to mutants/Auctions/Auctions.mutant.386.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if false)...VALID [written to mutants/Auctions/Auctions.mutant.387.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_         if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.388.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True  auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.389.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if  is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.390.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction  settled by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.391.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is  by the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.392.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled  the take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.393.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by  take action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.394.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the  action. (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.395.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take  (NFT take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.396.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action.  take: rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.397.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT  rebalance borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.398.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take:  borrower collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.399.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance  collateral in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.400.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower  in pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.401.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral  pool if true)...VALID [written to mutants/Auctions/Auctions.mutant.402.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in  if true)...VALID [written to mutants/Auctions/Auctions.mutant.403.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool  true)...VALID [written to mutants/Auctions/Auctions.mutant.404.sol] 
PROCESSING MUTANT: 1026:      *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if true)  ==>       *  @return settledAuction_        True if auction is settled by the take action. (NFT take: rebalance borrower collateral in pool if ...VALID [written to mutants/Auctions/Auctions.mutant.405.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       +  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.406.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       -  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.407.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       /  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.408.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       %  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.409.sol] 
     break;...VALID [written to mutants/Auctions/Auctions.mutant.410.sol] 
     continue;...VALID [written to mutants/Auctions/Auctions.mutant.411.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_    collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.412.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower  remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.413.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral  after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.414.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining  take action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.415.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after  action. (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.416.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take  (NFT take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.417.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action.  take: collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.418.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT  collateral to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.419.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take:  to be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.420.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral  be rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.421.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to  rebalanced in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.422.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be  in case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.423.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced  case of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.424.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in  of NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.425.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case  NFT settlement)...VALID [written to mutants/Auctions/Auctions.mutant.426.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of  settlement)...VALID [written to mutants/Auctions/Auctions.mutant.427.sol] 
PROCESSING MUTANT: 1027:      *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT settlement)  ==>       *  @return remainingCollateral_   Borrower collateral remaining after take action. (NFT take: collateral to be rebalanced in case of NFT ...VALID [written to mutants/Auctions/Auctions.mutant.428.sol] 
PROCESSING MUTANT: 1045:         uint256 borrowerDebt = Maths.wmul(borrower_.t0Debt, poolState_.inflator);  ==>          uint256 borrowerDebt = Maths.wmul( poolState_.inflator,borrower_.t0Debt);...VALID [written to mutants/Auctions/Auctions.mutant.429.sol] 
PROCESSING MUTANT: 1058:         remainingCollateral_ = borrower_.collateral;  ==>          /*remainingCollateral_ = borrower_.collateral;*/...VALID [written to mutants/Auctions/Auctions.mutant.430.sol] 
PROCESSING MUTANT: 1087:             settledAuction_ // stamp borrower t0Np if exiting from auction  ==>              settledAuction_ // stamp borrower t1Np if exiting from auction...VALID [written to mutants/Auctions/Auctions.mutant.431.sol] 
PROCESSING MUTANT: 1087:             settledAuction_ // stamp borrower t0Np if exiting from auction  ==>              settledAuction_ // stamp borrower t-1Np if exiting from auction...VALID [written to mutants/Auctions/Auctions.mutant.432.sol] 
PROCESSING MUTANT: 1087:             settledAuction_ // stamp borrower t0Np if exiting from auction  ==>              settledAuction_ // stamp borrower t(0+1)Np if exiting from auction...VALID [written to mutants/Auctions/Auctions.mutant.433.sol] 
PROCESSING MUTANT: 1087:             settledAuction_ // stamp borrower t0Np if exiting from auction  ==>              settledAuction_ // stamp borrower t(0-1)Np if exiting from auction...VALID [written to mutants/Auctions/Auctions.mutant.434.sol] 
PROCESSING MUTANT: 1087:             settledAuction_ // stamp borrower t0Np if exiting from auction  ==>              settledAuction_ //  borrower t0Np if exiting from auction...VALID [written to mutants/Auctions/Auctions.mutant.435.sol] 
PROCESSING MUTANT: 1101:     ) internal pure returns (uint256 bondFactor_, uint256 bondSize_) {  ==>      ) internal view returns (uint256 bondFactor_, uint256 bondSize_) {...VALID [written to mutants/Auctions/Auctions.mutant.436.sol] 
PROCESSING MUTANT: 1101:     ) internal pure returns (uint256 bondFactor_, uint256 bondSize_) {  ==>      ) internal  returns (uint256 bondFactor_, uint256 bondSize_) {...VALID [written to mutants/Auctions/Auctions.mutant.437.sol] 
PROCESSING MUTANT: 1105:         if (thresholdPrice >= momp_) {  ==>          if (thresholdPrice > momp_) {...VALID [written to mutants/Auctions/Auctions.mutant.438.sol] 
PROCESSING MUTANT: 1117:         bondSize_ = Maths.wmul(bondFactor_,  borrowerDebt_);  ==>          bondSize_ = Maths.wmul(  borrowerDebt_,bondFactor_);...VALID [written to mutants/Auctions/Auctions.mutant.439.sol] 
PROCESSING MUTANT: 1137:         if (kickerClaimable >= bondSize_) {  ==>          if (kickerClaimable > bondSize_) {...VALID [written to mutants/Auctions/Auctions.mutant.440.sol] 
PROCESSING MUTANT: 1138:             kicker.claimable -= bondSize_;  ==>              kicker.claimable %= bondSize_;...VALID [written to mutants/Auctions/Auctions.mutant.441.sol] 
PROCESSING MUTANT: 1143:             bondDifference_  = bondSize_ - kickerClaimable;  ==>              bondDifference_  = bondSize_ + kickerClaimable;...VALID [written to mutants/Auctions/Auctions.mutant.442.sol] 
PROCESSING MUTANT: 1144:             kicker.claimable = 0;  ==>              /*kicker.claimable = 0;*/...VALID [written to mutants/Auctions/Auctions.mutant.443.sol] 
PROCESSING MUTANT: 1147:             auctions_.totalBondEscrowed -= kickerClaimable;  ==>              auctions_.totalBondEscrowed += kickerClaimable;...VALID [written to mutants/Auctions/Auctions.mutant.444.sol] 
PROCESSING MUTANT: 1147:             auctions_.totalBondEscrowed -= kickerClaimable;  ==>              /*auctions_.totalBondEscrowed -= kickerClaimable;*/...VALID [written to mutants/Auctions/Auctions.mutant.445.sol] 
PROCESSING MUTANT: 1162:     ) internal pure returns (  ==>      ) internal view returns (...VALID [written to mutants/Auctions/Auctions.mutant.446.sol] 
PROCESSING MUTANT: 1162:     ) internal pure returns (  ==>      ) internal  returns (...VALID [written to mutants/Auctions/Auctions.mutant.447.sol] 
PROCESSING MUTANT: 1169:         uint256 borrowerPrice        = (vars.isRewarded) ? Maths.wmul(borrowerPayoffFactor, vars.auctionPrice) : vars.auctionPrice;  ==>          uint256 borrowerPrice        = (vars.isRewarded) ? Maths.wmul( vars.auctionPrice,borrowerPayoffFactor) : vars.auctionPrice;...VALID [written to mutants/Auctions/Auctions.mutant.448.sol] 
PROCESSING MUTANT: 1172:         vars.quoteTokenAmount = (vars.unscaledDeposit != type(uint256).max) ? Maths.wmul(vars.unscaledDeposit, vars.bucketScale) : type(uint256).max;  ==>          vars.quoteTokenAmount = (vars.unscaledDeposit < type(uint256).max) ? Maths.wmul(vars.unscaledDeposit, vars.bucketScale) : type(uint256).max;...VALID [written to mutants/Auctions/Auctions.mutant.449.sol] 
PROCESSING MUTANT: 1172:         vars.quoteTokenAmount = (vars.unscaledDeposit != type(uint256).max) ? Maths.wmul(vars.unscaledDeposit, vars.bucketScale) : type(uint256).max;  ==>          vars.quoteTokenAmount = (vars.unscaledDeposit != type(uint256).max) ? Maths.wmul( vars.bucketScale,vars.unscaledDeposit) : type(uint256).max;...VALID [written to mutants/Auctions/Auctions.mutant.450.sol] 
PROCESSING MUTANT: 1174:         uint256 borrowerCollateralValue = Maths.wmul(totalCollateral_, borrowerPrice);  ==>          uint256 borrowerCollateralValue = Maths.wmul( borrowerPrice,totalCollateral_);...VALID [written to mutants/Auctions/Auctions.mutant.451.sol] 
PROCESSING MUTANT: 1176:         if (vars.quoteTokenAmount <= vars.borrowerDebt && vars.quoteTokenAmount <= borrowerCollateralValue) {  ==>          if (vars.quoteTokenAmount <= vars.borrowerDebt && vars.quoteTokenAmount != borrowerCollateralValue) {...VALID [written to mutants/Auctions/Auctions.mutant.452.sol] 
PROCESSING MUTANT: 1176:         if (vars.quoteTokenAmount <= vars.borrowerDebt && vars.quoteTokenAmount <= borrowerCollateralValue) {  ==>          if (vars.quoteTokenAmount < vars.borrowerDebt && vars.quoteTokenAmount <= borrowerCollateralValue) {...VALID [written to mutants/Auctions/Auctions.mutant.453.sol] 
PROCESSING MUTANT: 1176:         if (vars.quoteTokenAmount <= vars.borrowerDebt && vars.quoteTokenAmount <= borrowerCollateralValue) {  ==>          if (vars.quoteTokenAmount <= vars.borrowerDebt && vars.quoteTokenAmount < borrowerCollateralValue) {...VALID [written to mutants/Auctions/Auctions.mutant.454.sol] 
PROCESSING MUTANT: 1176:         if (vars.quoteTokenAmount <= vars.borrowerDebt && vars.quoteTokenAmount <= borrowerCollateralValue) {  ==>          if (vars.quoteTokenAmount <= vars.borrowerDebt && (1==1)) {...VALID [written to mutants/Auctions/Auctions.mutant.455.sol] 
PROCESSING MUTANT: 1182:             vars.quoteTokenAmount         = Maths.wmul(vars.collateralAmount, vars.auctionPrice);  ==>              vars.quoteTokenAmount         = Maths.wmul( vars.auctionPrice,vars.collateralAmount);...VALID [written to mutants/Auctions/Auctions.mutant.456.sol] 
PROCESSING MUTANT: 1184:         } else if (vars.borrowerDebt <= borrowerCollateralValue) {  ==>          } else if (vars.borrowerDebt < borrowerCollateralValue) {...VALID [written to mutants/Auctions/Auctions.mutant.457.sol] 
PROCESSING MUTANT: 1198:             vars.quoteTokenAmount         = Maths.wmul(vars.collateralAmount, vars.auctionPrice);  ==>              vars.quoteTokenAmount         = Maths.wmul( vars.auctionPrice,vars.collateralAmount);...VALID [written to mutants/Auctions/Auctions.mutant.458.sol] 
PROCESSING MUTANT: 1234:         if (liquidation.kickTime != 0) revert AuctionActive();  ==>          if (liquidation.kickTime > 0) revert AuctionActive();...VALID [written to mutants/Auctions/Auctions.mutant.459.sol] 
PROCESSING MUTANT: 1240:         liquidation.bondSize     = uint160(bondSize_);  ==>          liquidation.bondSize     = uint80(bondSize_);...VALID [written to mutants/Auctions/Auctions.mutant.460.sol] 
PROCESSING MUTANT: 1251:         if (auctions_.head != address(0)) {  ==>          if (auctions_.head > address(0)) {...VALID [written to mutants/Auctions/Auctions.mutant.461.sol] 
PROCESSING MUTANT: 1277:         Liquidation memory liquidation = auctions_.liquidations[borrower_];  ==>          Liquidation storage liquidation = auctions_.liquidations[borrower_];...VALID [written to mutants/Auctions/Auctions.mutant.462.sol] 
PROCESSING MUTANT: 1288:         if (auctions_.head == borrower_ && auctions_.tail == borrower_) {  ==>          if (auctions_.head == borrower_ && auctions_.tail >= borrower_) {...VALID [written to mutants/Auctions/Auctions.mutant.463.sol] 
PROCESSING MUTANT: 1288:         if (auctions_.head == borrower_ && auctions_.tail == borrower_) {  ==>          if (auctions_.head == borrower_ && auctions_.tail > borrower_) {...VALID [written to mutants/Auctions/Auctions.mutant.464.sol] 
PROCESSING MUTANT: 1288:         if (auctions_.head == borrower_ && auctions_.tail == borrower_) {  ==>          if (false) {...VALID [written to mutants/Auctions/Auctions.mutant.465.sol] 
PROCESSING MUTANT: 1288:         if (auctions_.head == borrower_ && auctions_.tail == borrower_) {  ==>          if (0==1) {...VALID [written to mutants/Auctions/Auctions.mutant.466.sol] 
PROCESSING MUTANT: 1290:             auctions_.head = address(0);  ==>              auctions_.head = ...VALID [written to mutants/Auctions/Auctions.mutant.467.sol] 
PROCESSING MUTANT: 1291:             auctions_.tail = address(0);  ==>              auctions_.tail = address(1);...VALID [written to mutants/Auctions/Auctions.mutant.468.sol] 
PROCESSING MUTANT: 1291:             auctions_.tail = address(0);  ==>              auctions_.tail = address((0+1));...VALID [written to mutants/Auctions/Auctions.mutant.469.sol] 
PROCESSING MUTANT: 1291:             auctions_.tail = address(0);  ==>              /*auctions_.tail = address(0);*/...VALID [written to mutants/Auctions/Auctions.mutant.470.sol] 
PROCESSING MUTANT: 1293:         else if(auctions_.head == borrower_) {  ==>           if(auctions_.head == borrower_) {...VALID [written to mutants/Auctions/Auctions.mutant.471.sol] 
PROCESSING MUTANT: 1298:         else if(auctions_.tail == borrower_) {  ==>          else if(auctions_.tail >= borrower_) {...VALID [written to mutants/Auctions/Auctions.mutant.472.sol] 
PROCESSING MUTANT: 1298:         else if(auctions_.tail == borrower_) {  ==>          else if(auctions_.tail > borrower_) {...VALID [written to mutants/Auctions/Auctions.mutant.473.sol] 
PROCESSING MUTANT: 1298:         else if(auctions_.tail == borrower_) {  ==>          else if(false) {...VALID [written to mutants/Auctions/Auctions.mutant.474.sol] 
PROCESSING MUTANT: 1298:         else if(auctions_.tail == borrower_) {  ==>          else if(0==1) {...VALID [written to mutants/Auctions/Auctions.mutant.475.sol] 
PROCESSING MUTANT: 1298:         else if(auctions_.tail == borrower_) {  ==>           if(auctions_.tail == borrower_) {...VALID [written to mutants/Auctions/Auctions.mutant.476.sol] 
PROCESSING MUTANT: 1301:             auctions_.tail = liquidation.prev;  ==>              /*auctions_.tail = liquidation.prev;*/...VALID [written to mutants/Auctions/Auctions.mutant.477.sol] 
PROCESSING MUTANT: 1303:         else {  ==>           {...VALID [written to mutants/Auctions/Auctions.mutant.478.sol] 
PROCESSING MUTANT: 1327:             liquidation_.bondSize                 += uint160(vars.bondChange);  ==>              liquidation_.bondSize                 += uint80(vars.bondChange);...VALID [written to mutants/Auctions/Auctions.mutant.479.sol] 
PROCESSING MUTANT: 1332:             vars.bondChange = Maths.min(liquidation_.bondSize, vars.bondChange);  ==>              vars.bondChange = Maths.min( vars.bondChange,liquidation_.bondSize);...VALID [written to mutants/Auctions/Auctions.mutant.480.sol] 
PROCESSING MUTANT: 1334:             liquidation_.bondSize                 -= uint160(vars.bondChange);  ==>              liquidation_.bondSize                 %= uint160(vars.bondChange);...VALID [written to mutants/Auctions/Auctions.mutant.481.sol] 
PROCESSING MUTANT: 1334:             liquidation_.bondSize                 -= uint160(vars.bondChange);  ==>              liquidation_.bondSize                 -= uint80(vars.bondChange);...VALID [written to mutants/Auctions/Auctions.mutant.482.sol] 
PROCESSING MUTANT: 1335:             auctions_.kickers[vars.kicker].locked -= vars.bondChange;  ==>              auctions_.kickers[vars.kicker].locked += vars.bondChange;...VALID [written to mutants/Auctions/Auctions.mutant.483.sol] 
PROCESSING MUTANT: 1335:             auctions_.kickers[vars.kicker].locked -= vars.bondChange;  ==>              auctions_.kickers[vars.kicker].locked *= vars.bondChange;...VALID [written to mutants/Auctions/Auctions.mutant.484.sol] 
PROCESSING MUTANT: 1335:             auctions_.kickers[vars.kicker].locked -= vars.bondChange;  ==>              /*auctions_.kickers[vars.kicker].locked -= vars.bondChange;*/...VALID [written to mutants/Auctions/Auctions.mutant.485.sol] 
PROCESSING MUTANT: 1367:         uint256 scaledDeposit = Maths.wmul(vars.unscaledDeposit, vars.bucketScale);  ==>          uint256 scaledDeposit = Maths.wmul( vars.bucketScale,vars.unscaledDeposit);...VALID [written to mutants/Auctions/Auctions.mutant.486.sol] 
PROCESSING MUTANT: 1381:             uint256 takerReward = Maths.wmul(vars.collateralAmount, vars.bucketPrice - vars.auctionPrice);  ==>              uint256 takerReward = Maths.wmul( vars.bucketPrice - vars.auctionPrice,vars.collateralAmount);...VALID [written to mutants/Auctions/Auctions.mutant.487.sol] 
PROCESSING MUTANT: 1398:             vars.bondChange = Maths.min(liquidation_.bondSize, vars.bondChange);  ==>              vars.bondChange = Maths.min( vars.bondChange,liquidation_.bondSize);...VALID [written to mutants/Auctions/Auctions.mutant.488.sol] 
PROCESSING MUTANT: 1400:             liquidation_.bondSize                 -= uint160(vars.bondChange);  ==>              liquidation_.bondSize                 -= uint80(vars.bondChange);...VALID [written to mutants/Auctions/Auctions.mutant.489.sol] 
PROCESSING MUTANT: 1406:         Deposits.unscaledRemove(deposits_, bucketIndex_, vars.unscaledQuoteTokenAmount); // remove quote tokens from buckets deposit  ==>          Deposits.unscaledRemove(deposits_, bucketIndex_, vars.unscaledQuoteTokenAmount); //  quote tokens from buckets deposit...VALID [written to mutants/Auctions/Auctions.mutant.490.sol] 
PROCESSING MUTANT: 1436:         elapsedHours -= Maths.min(elapsedHours, 1e18);  // price locked during cure period  ==>          elapsedHours -= Maths.min( 1e18,elapsedHours);  // price locked during cure period...VALID [written to mutants/Auctions/Auctions.mutant.491.sol] 
PROCESSING MUTANT: 1436:         elapsedHours -= Maths.min(elapsedHours, 1e18);  // price locked during cure period  ==>          elapsedHours -= Maths.min(elapsedHours, 1e18);  //  locked during cure period...VALID [written to mutants/Auctions/Auctions.mutant.492.sol] 
PROCESSING MUTANT: 1439:         uint256 referencePrice = Maths.max(kickMomp_, neutralPrice_);   ==>          uint256 referencePrice = Maths.max( neutralPrice_,kickMomp_); ...VALID [written to mutants/Auctions/Auctions.mutant.493.sol] 
PROCESSING MUTANT: 1460:     ) internal pure returns (int256) {  ==>      ) internal view returns (int256) {...VALID [written to mutants/Auctions/Auctions.mutant.494.sol] 
PROCESSING MUTANT: 1460:     ) internal pure returns (int256) {  ==>      ) internal  returns (int256) {...VALID [written to mutants/Auctions/Auctions.mutant.495.sol] 
PROCESSING MUTANT: 1464:         if (thresholdPrice < int256(neutralPrice_)) {  ==>          if (thresholdPrice <= int256(neutralPrice_)) {...VALID [written to mutants/Auctions/Auctions.mutant.496.sol] 
PROCESSING MUTANT: 1469:                     -1 * 1e18,  ==>                      -1 - 1e18,...VALID [written to mutants/Auctions/Auctions.mutant.497.sol] 
PROCESSING MUTANT: 1469:                     -1 * 1e18,  ==>                      -(1+1) * 1e18,...VALID [written to mutants/Auctions/Auctions.mutant.498.sol] 
PROCESSING MUTANT: 1478:             if (val < 0 )      sign = -1e18;  ==>              if (val <= 0 )      sign = -1e18;...VALID [written to mutants/Auctions/Auctions.mutant.499.sol] 
PROCESSING MUTANT: 1478:             if (val < 0 )      sign = -1e18;  ==>              if (val < 1 )      sign = -1e18;...VALID [written to mutants/Auctions/Auctions.mutant.500.sol] 
PROCESSING MUTANT: 1478:             if (val < 0 )      sign = -1e18;  ==>              if (val < -1 )      sign = -1e18;...VALID [written to mutants/Auctions/Auctions.mutant.501.sol] 
PROCESSING MUTANT: 1478:             if (val < 0 )      sign = -1e18;  ==>              if (val < (0+1) )      sign = -1e18;...VALID [written to mutants/Auctions/Auctions.mutant.502.sol] 
PROCESSING MUTANT: 1478:             if (val < 0 )      sign = -1e18;  ==>              if (val < (0-1) )      sign = -1e18;...VALID [written to mutants/Auctions/Auctions.mutant.503.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (val >= 0) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.504.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (val > 0) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.505.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (val != 1) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.506.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (val != -1) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.507.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (val != (0+1)) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.508.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (val != (0-1)) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.509.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (true) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.510.sol] 
PROCESSING MUTANT: 1479:             else if (val != 0) sign = 1e18;  ==>              else if (1==1) sign = 1e18;...VALID [written to mutants/Auctions/Auctions.mutant.511.sol] 
PROCESSING MUTANT: 1482:         return PRBMathSD59x18.mul(int256(bondFactor_), sign);  ==>          return PRBMathSD59x18.mul( sign,int256(bondFactor_));...VALID [written to mutants/Auctions/Auctions.mutant.512.sol] 
PROCESSING MUTANT: 1506:         if (kickTime == 0) revert NoAuction();  ==>          if (kickTime <= 0) revert NoAuction();...VALID [written to mutants/Auctions/Auctions.mutant.513.sol] 
PROCESSING MUTANT: 1507:         if (block.timestamp - kickTime <= 1 hours) revert TakeNotPastCooldown();  ==>          if (block.timestamp % kickTime <= 1 hours) revert TakeNotPastCooldown();...VALID [written to mutants/Auctions/Auctions.mutant.514.sol] 
PROCESSING MUTANT: 1507:         if (block.timestamp - kickTime <= 1 hours) revert TakeNotPastCooldown();  ==>          if (block.timestamp - kickTime < 1 hours) revert TakeNotPastCooldown();...VALID [written to mutants/Auctions/Auctions.mutant.515.sol] 
PROCESSING MUTANT: 1513:             vars.t0DebtPenalty  = Maths.wmul(t0Debt_, 0.07 * 1e18);  ==>              vars.t0DebtPenalty  = Maths.wmul( 0.07 * 1e18,t0Debt_);...VALID [written to mutants/Auctions/Auctions.mutant.516.sol] 
PROCESSING MUTANT: 1519:         vars.borrowerDebt = Maths.wmul(vars.t0BorrowerDebt, inflator_);  ==>          vars.borrowerDebt = Maths.wmul( inflator_,vars.t0BorrowerDebt);...VALID [written to mutants/Auctions/Auctions.mutant.517.sol] 
PROCESSING MUTANT: 1523:         vars.auctionPrice = _auctionPrice(liquidation_.kickMomp, neutralPrice, kickTime);  ==>          vars.auctionPrice = _auctionPrice( neutralPrice,liquidation_.kickMomp, kickTime);...VALID [written to mutants/Auctions/Auctions.mutant.518.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 + Maths.maxInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.519.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 * Maths.maxInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.520.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(0e18 - Maths.maxInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.521.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e0 - Maths.maxInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.522.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e1 - Maths.maxInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.523.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 - Maths.maxInt(1, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.524.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(-1e18 - Maths.maxInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.525.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 - Maths.maxInt(-1, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.526.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 - Maths.maxInt((0+1), vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.527.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 - Maths.maxInt((0-1), vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.528.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 - Maths.maxInt( vars.bpf,0));...VALID [written to mutants/Auctions/Auctions.mutant.529.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          vars.factor       = uint256(1e18 - Maths.minInt(0, vars.bpf));...VALID [written to mutants/Auctions/Auctions.mutant.530.sol] 
PROCESSING MUTANT: 1531:         vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));  ==>          /*vars.factor       = uint256(1e18 - Maths.maxInt(0, vars.bpf));*/...VALID [written to mutants/Auctions/Auctions.mutant.531.sol] 
PROCESSING MUTANT: 1533:         vars.isRewarded   = (vars.bpf  >= 0);  ==>          vars.isRewarded   = (vars.bpf  > 0);...VALID [written to mutants/Auctions/Auctions.mutant.532.sol] 
PROCESSING MUTANT: 1533:         vars.isRewarded   = (vars.bpf  >= 0);  ==>          vars.isRewarded   = (vars.bpf  >= 1);...VALID [written to mutants/Auctions/Auctions.mutant.533.sol] 
PROCESSING MUTANT: 1533:         vars.isRewarded   = (vars.bpf  >= 0);  ==>          vars.isRewarded   = (vars.bpf  >= -1);...VALID [written to mutants/Auctions/Auctions.mutant.534.sol] 
PROCESSING MUTANT: 1533:         vars.isRewarded   = (vars.bpf  >= 0);  ==>          vars.isRewarded   = (vars.bpf  >= (0+1));...VALID [written to mutants/Auctions/Auctions.mutant.535.sol] 
PROCESSING MUTANT: 1533:         vars.isRewarded   = (vars.bpf  >= 0);  ==>          vars.isRewarded   = (vars.bpf  >= (0-1));...VALID [written to mutants/Auctions/Auctions.mutant.536.sol] 
PROCESSING MUTANT: 1543:     ) internal view returns (uint256) {  ==>      ) internal  returns (uint256) {...VALID [written to mutants/Auctions/Auctions.mutant.537.sol] 
538 VALID MUTANTS
10084 INVALID MUTANTS
0 REDUNDANT MUTANTS
Valid Percentage: 5.064959517981547%
